---@diagnostic disable: undefined-global
return {
	-- =========================
	-- LSP/补全相关：LSP 安装与自动补全
	-- =========================
	{
		"williamboman/mason.nvim",
		build = ":MasonUpdate",
		opts = {
			ensure_installed = { "clangd", "marksman" },
			ui = {
				border = "rounded",
				width = 0.8,
				height = 0.7,
				icons = {
					package_installed = "✓",
					package_pending = "➜",
					package_uninstalled = "✗",
				},
			},
		},

		config = function(_, opts)
			require("mason").setup(opts)
			local mr = require("mason-registry")

			local function ensure_installed()
				for _, tool in ipairs(opts.ensure_installed) do
					local p = mr.get_package(tool)
					if not p:is_installed() and not p:is_installing() then
						p:install()
					end
				end
			end

			if mr.refresh then
				mr.refresh(function()
					ensure_installed()
				end)
			else
				ensure_installed()
			end
		end,
	},

	-- blink.cmp 完整配置示例
	{
		"saghen/blink.cmp",
		version = "1.*",
		dependencies = {
			"L3MON4D3/LuaSnip",
		},
		opts = {
			fuzzy = {
				implementation = "lua",
			},
			cmdline = {
				-- list = { selection = { preselect = true, auto_insert = true } },
				keymap = {
					["<CR>"] = { "select_and_accept", "fallback" },
				},
			},
			completion = {
				menu = {
					auto_show = true,
				},
				ghost_text = { enabled = false },
				keyword = { range = "full" },
				documentation = { auto_show = true, auto_show_delay_ms = 0 },
			},
			keymap = {
				preset = "none",
				["<C-space>"] = { "show", "show_documentation", "hide_documentation" },
				["<CR>"] = { "accept", "fallback" },
				["<S-Tab>"] = { "select_prev", "snippet_backward", "fallback" },
				["<Tab>"] = { "select_next", "snippet_forward", "fallback" },
				["<C-b>"] = { "scroll_documentation_up", "fallback" },
				["<C-f>"] = { "scroll_documentation_down", "fallback" },
				["<C-u>"] = { "snippet_backward", "select_prev", "fallback" },
			},
			enabled = function()
				return vim.bo.buftype == "" or vim.bo.buftype == "acwrite"
			end,
			appearance = {
				use_nvim_cmp_as_default = true,
				nerd_font_variant = "mono",
			},
			sources = {
				default = {
					"buffer",
					"lsp",
					"path",
					"snippets",
				},
				providers = {
					buffer = { score_offset = 3 },
					path = { score_offset = 2 },
					lsp = { score_offset = 2 },
					snippets = { score_offset = 4, min_keyword_length = 1 },
					cmdline = {
						min_keyword_length = function(ctx)
							if ctx.mode == "cmdline" and string.find(ctx.line, " ") == nil then
								return 2
							end
							return 0
						end,
					},
				},
			},
		},
		config = function(_, opts)
			require("blink.cmp").setup(opts)
			-- 1. 加载 snipmate/UltiSnips 格式的 .snippets 文件
			require("luasnip.loaders.from_snipmate").lazy_load({
				paths = { vim.fn.stdpath("config") .. "/snippets" },
			})
			-- 2. 加载 friendly-snippets（VSCode 格式）
			-- require("luasnip.loaders.from_vscode").lazy_load()
		end,
	},

	-- LSP 配置与快捷键
	{
		"neovim/nvim-lspconfig",
		dependencies = {
			"saghen/blink.cmp",
			"L3MON4D3/LuaSnip",
			"nvim-treesitter/nvim-treesitter-textobjects",
			"williamboman/mason.nvim",
		},
		config = function()
			-- 设置 LSP Hover 窗口为圆角边框
			vim.lsp.handlers["textDocument/hover"] = vim.lsp.with(vim.lsp.handlers.hover, { border = "rounded" })

			-- clangd 配置
			vim.lsp.config("clangd", {
				cmd = { "clangd" },
				filetypes = { "c", "cpp", "objc", "objcpp", "cuda" },
				root_markers = {
					".clangd",
					".clang-tidy",
					".clang-format",
					"compile_commands.json",
					"compile_flags.txt",
					"configure.ac",
					".git",
				},
				capabilities = vim.tbl_deep_extend("force", require("blink.cmp").get_lsp_capabilities(), {
					textDocument = {
						completion = {
							editsNearCursor = true,
						},
					},
					offsetEncoding = { "utf-8", "utf-16" },
				}),
				on_init = function(client, init_result)
					if init_result.offsetEncoding then
						client.offset_encoding = init_result.offsetEncoding
					end
				end,
				on_attach = function(client, bufnr)
					-- 源/头切换命令
					vim.api.nvim_buf_create_user_command(bufnr, "LspClangdSwitchSourceHeader", function()
						-- 你需要实现 switch_source_header 函数
						switch_source_header(bufnr, client)
					end, { desc = "Switch between source/header" })

					-- 符号信息命令
					vim.api.nvim_buf_create_user_command(bufnr, "LspClangdShowSymbolInfo", function()
						-- 你需要实现 symbol_info 函数
						symbol_info(bufnr, client)
					end, { desc = "Show symbol info" })

					-- 高亮光标下单词
					if
						client
						and client.supports_method(vim.lsp.protocol.Methods.textDocument_documentHighlight)
						and vim.bo.filetype ~= "bigfile"
					then
						local highlight_augroup =
							vim.api.nvim_create_augroup("kickstart-lsp-highlight", { clear = false })
						vim.api.nvim_create_autocmd({ "CursorHold", "CursorHoldI" }, {
							buffer = bufnr,
							group = highlight_augroup,
							callback = vim.lsp.buf.document_highlight,
						})
						vim.api.nvim_create_autocmd({ "CursorMoved", "CursorMovedI" }, {
							buffer = bufnr,
							group = highlight_augroup,
							callback = vim.lsp.buf.clear_references,
						})
						vim.api.nvim_create_autocmd("LspDetach", {
							group = vim.api.nvim_create_augroup("kickstart-lsp-detach", { clear = true }),
							callback = function(event2)
								vim.lsp.buf.clear_references()
								vim.api.nvim_clear_autocmds({ group = "kickstart-lsp-highlight", buffer = event2.buf })
							end,
						})
					end
				end,
			})

			-- 其他 LSP 配置
			vim.lsp.config("marksman", {
				capabilities = require("blink.cmp").get_lsp_capabilities(),
			})

			vim.lsp.enable("clangd")
			vim.lsp.enable("marksman")

			vim.diagnostic.config({
				underline = false,
				signs = false,
				update_in_insert = false,
				virtual_text = { spacing = 2, prefix = "●" },
				severity_sort = true,
				float = { border = "rounded" },
			})

			vim.api.nvim_create_autocmd("LspAttach", {
				group = vim.api.nvim_create_augroup("UserLspConfig", {}),
				callback = function(ev)
					local opts = { buffer = ev.buf, silent = true }
					vim.keymap.set("n", "[g", vim.diagnostic.goto_prev, opts)
					vim.keymap.set("n", "]g", vim.diagnostic.goto_next, opts)
					vim.keymap.set("n", "gd", vim.lsp.buf.definition, opts)
					vim.keymap.set("n", "gy", vim.lsp.buf.type_definition, opts)
					vim.keymap.set("n", "gi", vim.lsp.buf.implementation, opts)
					vim.keymap.set("n", "gr", vim.lsp.buf.references, opts)
					vim.keymap.set("n", "K", vim.lsp.buf.hover, opts)
					vim.keymap.set("n", "<leader>rn", vim.lsp.buf.rename, opts)
					vim.keymap.set("n", "<leader>a", vim.lsp.buf.code_action, opts)
					vim.keymap.set("x", "<leader>a", vim.lsp.buf.code_action, opts)
					vim.keymap.set("n", "<leader>ac", function()
						vim.lsp.buf.code_action({ context = { only = { "quickfix" } } })
					end, opts)
					vim.keymap.set("n", "<leader>as", function()
						vim.lsp.buf.code_action({ context = { only = { "source" } } })
					end, opts)
					vim.keymap.set("n", "<leader>qf", function()
						vim.lsp.buf.code_action({ context = { only = { "quickfix" } } })
					end, opts)
					vim.keymap.set("n", "<leader>re", function()
						vim.lsp.buf.code_action({ context = { only = { "refactor" } } })
					end, opts)
					vim.keymap.set("x", "<leader>r", function()
						vim.lsp.buf.code_action({ context = { only = { "refactor" } } })
					end, opts)
					vim.keymap.set("n", "<leader>r", function()
						vim.lsp.buf.code_action({ context = { only = { "refactor" } } })
					end, opts)
					vim.keymap.set("n", "<leader>cl", vim.lsp.codelens.run, opts)
					vim.api.nvim_create_autocmd("BufWritePre", {
						buffer = ev.buf,
						callback = function()
							vim.lsp.buf.format({ async = false })
						end,
					})
				end,
			})
			vim.api.nvim_create_user_command("Fold", function(opts)
				vim.lsp.buf.range_code_action({ only = { "source.organizeImports" } })
			end, { nargs = "?" })
			vim.api.nvim_create_user_command("OR", function()
				vim.lsp.buf.code_action({ context = { only = { "source.organizeImports" } } })
			end, {})
		end,
	},

	-- treesitter textobjects：代码结构对象选择与跳转
	{
		"nvim-treesitter/nvim-treesitter-textobjects",
		dependencies = { -- 依赖 treesitter 主体
		},
		config = function()
			require("nvim-treesitter.configs").setup({
				textobjects = {
					select = {
						enable = true,
						lookahead = true,
						keymaps = {
							["af"] = "@function.outer",
							["if"] = "@function.inner",
							["ac"] = "@class.outer",
							["ic"] = "@class.inner",
						},
					},
					move = {
						enable = true,
						set_jumps = true,
						goto_next_start = { ["]f"] = "@function.outer", ["]c"] = "@class.outer" },
						goto_previous_start = { ["[f"] = "@function.outer", ["[c"] = "@class.outer" },
					},
				},
			})
		end,
	},
}
