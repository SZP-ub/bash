---@diagnostic disable: undefined-global

return {
	-- =========================
	-- mason.nvim：只负责 LSP / 工具 安装
	-- =========================
	{
		"mason-org/mason.nvim",
		event = "VeryLazy",
		opts = {
			ui = {
				border = "rounded",
				width = 0.8,
				height = 0.7,
				icons = {
					package_installed = "✓",
					package_pending = "➜",
					package_uninstalled = "✗",
				},
			},
		},
		config = function(_, opts)
			require("mason").setup(opts)
		end,
	},

	-- =========================
	-- mason-lspconfig：LSP server 安装 + 启动内置 LSP 配置
	-- =========================
	{
		"mason-org/mason-lspconfig.nvim",
		dependencies = {
			{ "mason-org/mason.nvim", opts = {} },
			"saghen/blink.cmp",
		},
		opts = {
			ensure_installed = {},
			automatic_installation = false,
		},
		config = function(_, opts)
			---------------------------------------------------------------------------
			-- 先按你的 opts 初始化 mason-lspconfig（保持原行为）
			---------------------------------------------------------------------------
			require("mason-lspconfig").setup(opts)

			---------------------------------------------------------------------------
			-- 1. 公共按键绑定：在 LspAttach 中设置
			---------------------------------------------------------------------------
			vim.api.nvim_create_autocmd("LspAttach", {
				group = vim.api.nvim_create_augroup("kickstart-lsp-attach", { clear = true }),
				callback = function(event)
					local map = function(keys, func, desc, mode)
						mode = mode or "n"
						vim.keymap.set(mode, keys, func, {
							buffer = event.buf,
							desc = "LSP: " .. desc,
							silent = true,
						})
					end

					-- ==== 对应 coc 中的 gd / gi / grt 等 ====
					map("gd", vim.lsp.buf.definition, "[G]oto [D]efinition") -- 跳转到定义
					map("gr", vim.lsp.buf.references, "[G]oto [R]eferences") -- 查找引用（类似 CocList references）
					map("gi", vim.lsp.buf.implementation, "[G]oto [I]mplementation") -- 跳到实现（类似 gi）
					map("grt", vim.lsp.buf.type_definition, "Type [D]efinition") -- 类型定义（类似 grt）
					-- map("<leader>ds", vim.lsp.buf.document_symbol, "[D]ocument [S]ymbols") -- 当前文档符号
					-- map("<leader>ws", vim.lsp.buf.workspace_symbol, "[W]orkspace [S]ymbols") -- 全工程符号

					map("K", vim.lsp.buf.hover, "Hover Documentation") -- 悬浮文档（类似 CocAction doHover）
					map("grn", vim.lsp.buf.rename, "[R]e[n]ame") -- 重命名符号（类似 grn）
					map("gra", vim.lsp.buf.code_action, "[C]ode [A]ction", { "n", "x" }) -- 代码操作（类似 <leader>a / gra）
					map("gD", vim.lsp.buf.declaration, "[G]oto [D]eclaration") -- 跳到声明

					map("[g", vim.diagnostic.goto_prev, "Previous Diagnostic") -- 上一条诊断（类似 coc-diagnostic-jump-prev）
					map("]g", vim.diagnostic.goto_next, "Next Diagnostic") -- 下一条诊断（类似 coc-diagnostic-jump-next）

					local client = vim.lsp.get_client_by_id(event.data.client_id)

					local function client_supports_method(method, bufnr)
						return client and client:supports_method(method, bufnr)
					end

					-- documentHighlight（对应 coc 的光标高亮同名符号）
					if
						client_supports_method(vim.lsp.protocol.Methods.textDocument_documentHighlight, event.buf)
						and vim.bo[event.buf].filetype ~= "bigfile"
					then
						local highlight_augroup =
							vim.api.nvim_create_augroup("kickstart-lsp-highlight", { clear = false })

						vim.api.nvim_create_autocmd({ "CursorHold", "CursorHoldI" }, {
							buffer = event.buf,
							group = highlight_augroup,
							callback = vim.lsp.buf.document_highlight,
						})

						vim.api.nvim_create_autocmd({ "CursorMoved", "CursorMovedI" }, {
							buffer = event.buf,
							group = highlight_augroup,
							callback = vim.lsp.buf.clear_references,
						})

						vim.api.nvim_create_autocmd("LspDetach", {
							group = vim.api.nvim_create_augroup("kickstart-lsp-detach", { clear = true }),
							callback = function(ev)
								vim.lsp.buf.clear_references()
								vim.api.nvim_clear_autocmds({
									group = "kickstart-lsp-highlight",
									buffer = ev.buf,
								})
							end,
						})
					end

					-- Inlay hints（coc 里对应某些扩展的 inline hints）
					if client_supports_method(vim.lsp.protocol.Methods.textDocument_inlayHint, event.buf) then
						map("<leader>th", function()
							vim.lsp.inlay_hint.enable(
								not vim.lsp.inlay_hint.is_enabled({ bufnr = event.buf }),
								{ bufnr = event.buf }
							)
						end, "[T]oggle Inlay [H]ints")
					end
				end,
			})

			---------------------------------------------------------------------------
			-- 2. 诊断 & hover 全局配置
			---------------------------------------------------------------------------
			vim.diagnostic.config({
				severity_sort = true,
				float = { border = "rounded", source = "if_many" },
				underline = { severity = vim.diagnostic.severity.ERROR },
				signs = {
					text = {
						[vim.diagnostic.severity.ERROR] = "󰅚 ",
						[vim.diagnostic.severity.WARN] = "󰀪 ",
						[vim.diagnostic.severity.INFO] = "󰋽 ",
						[vim.diagnostic.severity.HINT] = "󰌶 ",
					},
				},
				virtual_text = {
					source = "if_many",
					spacing = 2,
					format = function(diagnostic)
						return diagnostic.message
					end,
				},
			})

			vim.lsp.handlers["textDocument/hover"] = vim.lsp.with(vim.lsp.handlers.hover, { border = "rounded" })

			---------------------------------------------------------------------------
			-- 3. 手动构造 LSP capabilities（替代 cmp_nvim_lsp 的 default_capabilities）
			--    这个 capabilities 可被传入到每个 server 的配置中，使得 blink.cmp
			--    等前端补全插件不需要依赖 cmp_nvim_lsp 来注入能力。
			---------------------------------------------------------------------------
			local base_capabilities = vim.lsp.protocol.make_client_capabilities()
			local capabilities = vim.tbl_deep_extend("force", base_capabilities, {
				textDocument = {
					completion = {
						completionItem = {
							snippetSupport = true,
							preselectSupport = true,
							insertReplaceSupport = true,
							labelDetailsSupport = true,
							deprecatedSupport = true,
							commitCharactersSupport = true,
							documentationFormat = { "markdown", "plaintext" },
							resolveSupport = {
								properties = { "documentation", "detail", "additionalTextEdits" },
							},
						},
					},
				},
			})

			---------------------------------------------------------------------------
			-- 4. 用 vim.lsp.config 定义/覆盖各个服务器配置（并把 capabilities 传入）
			---------------------------------------------------------------------------
			-- clangd：C / C++
			vim.lsp.config("clangd", {
				name = "clangd",
				cmd = { "clangd" },
				filetypes = { "c", "cpp", "objc", "objcpp", "cuda" },
				root_markers = {
					{ ".clangd", ".clang-tidy", ".clang-format" },
					"compile_commands.json",
					"compile_flags.txt",
					"configure.ac",
					".git",
				},
				capabilities = vim.tbl_deep_extend("force", capabilities, {
					textDocument = { completion = { editsNearCursor = true } },
					offsetEncoding = { "utf-8", "utf-16" },
				}),
				on_init = function(client, init_result)
					if init_result and init_result.offsetEncoding then
						client.offset_encoding = init_result.offsetEncoding
					end
				end,
			})

			-- lua-language-server
			vim.lsp.config("lua_ls", {
				name = "lua_ls",
				cmd = {
					"/home/i/tools/lua-language-server-3.16.1-linux-x64/bin/lua-language-server",
				},
				filetypes = { "lua" },
				root_markers = {
					{ ".luarc.json", ".luarc.jsonc" },
					".git",
				},
				settings = {
					Lua = {
						workspace = { checkThirdParty = false },
						hint = { enable = true },
					},
				},
				capabilities = capabilities,
			})

			-- marksman
			vim.lsp.config("marksman", {
				name = "marksman",
				cmd = { "marksman", "server" },
				filetypes = { "markdown", "markdown.mdx" },
				root_markers = { ".git" },
				capabilities = capabilities,
			})

			-- pyright
			vim.lsp.config("pyright", {
				name = "pyright",
				cmd = { "pyright-langserver", "--stdio" },
				filetypes = { "python" },
				root_markers = {
					"pyrightconfig.json",
					"pyproject.toml",
					"setup.py",
					"setup.cfg",
					"requirements.txt",
					"Pipfile",
					".git",
				},
				capabilities = capabilities,
			})

			-- jsonls（JSON / JSONC）
			vim.lsp.config("jsonls", {
				name = "jsonls",
				cmd = { "vscode-json-language-server", "--stdio" },
				filetypes = { "json", "jsonc" },
				root_markers = {
					"package.json",
					"tsconfig.json",
					".git",
				},
				settings = {
					json = {
						validate = { enable = true },
						-- 如果你没有安装 schemastore.nvim，就删掉 schemas 这一行
						-- schemas = require("schemastore").json.schemas(),
					},
				},
				capabilities = capabilities,
			})

			---------------------------------------------------------------------------
			-- 5. mason 安装 + 启用这些配置（自动按 filetype 启动）
			---------------------------------------------------------------------------
			local mason = require("mason")
			local mason_lspconfig = require("mason-lspconfig")

			mason.setup({})

			mason_lspconfig.setup({
				ensure_installed = { "clangd", "lua_ls", "marksman", "pyright" },
				automatic_installation = true,
			})

			-- 自动按 filetype attach，无需 :LspStart
			vim.lsp.enable({
				"clangd",
				"lua_ls",
				"marksman",
				"pyright",
				"jsonls",
			})

			---------------------------------------------------------------------------
			-- 6. 组织 imports 的用户命令（对应 coc 中的 Fold / OR）
			---------------------------------------------------------------------------
			-- vim.api.nvim_create_user_command("Fold", function()
			-- 	vim.lsp.buf.range_code_action({ only = { "source.organizeImports" } })
			-- end, { nargs = "?" })

			-- vim.api.nvim_create_user_command("OR", function()
			-- 	vim.lsp.buf.code_action({ context = { only = { "source.organizeImports" } } })
			-- end, {})
		end,
	},

	-- =========================
	-- blink.cmp 补全（对应 coc 的补全功能）
	-- =========================
	{
		"saghen/blink.cmp",
		version = "1.*",
		dependencies = {
			-- snippet 引擎（如果需要 snippets，请启用）
			{ "L3MON4D3/LuaSnip", version = "v2.*" },
			"xzbdmw/colorful-menu.nvim",
			"saadparwaiz1/cmp_luasnip",
			-- blink.compat：允许使用 nvim-cmp 的源（通过兼容层）
			{
				"saghen/blink.compat",
				version = "2.*",
				-- lazy.nvim 可保证在需要时加载该插件，且 blink.cmp 会在运行时 require 它
				lazy = true,
				-- blink.compat 支持的 opts（参见仓库 README / config.lua）
				opts = {
					-- 打开调试输出（便于排查）
					debug = true,
					-- 如果你希望兼容更多以 nvim-cmp 为目标的插件/源，可以启用 impersonate
					impersonate_nvim_cmp = true,
				},
			},
		},

		opts = {
			keymap = {
				preset = "none",
				["<C-space>"] = { "show", "show_documentation", "hide_documentation" }, -- 类似 Coc 的 <C-Space> 手动补全
				["<CR>"] = { "accept", "fallback" }, -- 类似 Coc 的回车确认补全
				["<Tab>"] = { "select_next", "snippet_forward", "fallback" }, -- 类似 Coc 的 Tab：下一个 item / snippet 跳转
				["<S-Tab>"] = { "select_prev", "snippet_backward", "fallback" }, -- 类似 Coc 的 S-Tab：上一个 item / snippet 反向跳
				-- ["<C-b>"] = { "scroll_documentation_up", "fallback" },
				-- ["<C-f>"] = { "scroll_documentation_down", "fallback" },
			},

			appearance = {
				use_nvim_cmp_as_default = true,
				nerd_font_variant = "mono",
			},

			completion = {
				menu = {
					auto_show = true,
					draw = {
						columns = { { "kind_icon" }, { "label", gap = 1 } },
						components = {
							label = {
								text = function(ctx)
									return require("colorful-menu").blink_components_text(ctx)
								end,
								highlight = function(ctx)
									return require("colorful-menu").blink_components_highlight(ctx)
								end,
							},
						},
					},
				},
				ghost_text = { enabled = false },
				keyword = { range = "full" },
				documentation = { auto_show = true, auto_show_delay_ms = 0 },
			},

			signature = { enabled = true },

			enabled = function()
				return vim.bo.buftype == "" or vim.bo.buftype == "acwrite"
			end,

			sources = {
				default = { "lsp", "path", "snippets", "buffer" },
				-- default = { "snippets" },
				providers = {
					buffer = { score_offset = 3 },
					path = { score_offset = 2 },
					lsp = { score_offset = 2 },
					snippets = { score_offset = 4, min_keyword_length = 1 },
					cmdline = {
						min_keyword_length = function(ctx)
							if ctx.mode == "cmdline" and string.find(ctx.line, " ") == nil then
								return 2
							end
							return 0
						end,
					},
				},
			},

			fuzzy = { implementation = "prefer_rust_with_warning" },

			cmdline = {
				keymap = {
					["<CR>"] = { "select_and_accept", "fallback" },
				},
			},
		},

		sources = {
			{ name = "luasnip" }, -- 必须有这个（用于 LuaSnip）
		},

		-- 将 sources.default 扩展到 opts.sources.default（保留原行为）
		opts_extend = { "sources.default" },
		config = function(_, opts)
			require("blink.cmp").setup(opts)
			-- 加载用户 snippets（如果存在）
			if pcall(require, "luasnip") then
				require("luasnip.loaders.from_snipmate").lazy_load({
					paths = { vim.fn.stdpath("config") .. "/snippets" },
				})
			end
		end,
	},
}
